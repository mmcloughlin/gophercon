A Go programmer's guide to syscalls -- Liz Rice
==============

[Background: Liz set up a container in <100 lines of code at a previous Gophercon]

[Further background: She frequently said in this talk, "We use syscalls to set up namespaces for a container."]


## What are syscalls?

>> A way that a program requests services from the kernel of the OS it's running on

Userspace code can't do very much on its own. Every time it wants to access hardware, it needs the kernel.

Example tasks: You can't start a process, access a device, access time without a syscall.


## Demo

Calling Linux command `strace` on a program displays the syscalls done by the program.

[Liz has a very simple program on the screen that prints something like "Hello world"]

She demos that its fmt.Println calls a syscall library.


## How does Go interface with syscalls?

Inside the syscall package, we have a bunch of OS specific packages and a bunch of autogenerated packages.

Every time we call the system code, what's happening?

>> syscall() saves the CPU registers before making system calls

Syscalls are really a portability layer. Allows us to emulate Linux. e.g., this is how Microsoft implement Bash on Windows.


### How do we know which system calls are being used?

`strace -c ./hello`

<<prints out all syscalls>>

If I wanted to run my program on some other platform, I need to port those syscalls.


## How does `strace` know which syscalls are running?

`strace` uses `ptrace`, which reads from a running process.

func ptrace(request int, pid int, addr uintptr, data uni) (err error) {
	// Go has an implementation of ptrace
}


## Let's build our own strace.

[Liz proceeds to use the ptrace implementation to build strace. It's cool. Watch her talk.]

## Syscalls for Security

Principle for security: Least privilege.

We know:
- Hello, World needed to use dozens of syscall.
- Of the 300 possible syscalls, only ~200 of them are ever used.
- ptrace is dangerous because it injects itself into other processes.

In the microservices world, we really only have a limited need for a few sets of syscalls.

You can actually specify which syscalls are allowed:

```
docker run \ 
 --security-opt <<seccomp file>>
```

## Let's build our own seccomp filter

[Liz proceeds to build a seccomp filter]

## In review...

- Syscall is your interface into the kernel
- It is used for portability
- We've seen strace and ptrace
- We've seen how security profiles

Code is at https://github.com/lizrice/strace-from-scratch

## Interesting Q+A info
- ptrace is the basis for a lot of malicious code but also debuggers
